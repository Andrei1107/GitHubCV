#include<iostream>
using namespace std;
#include<vector>
#include<list>


class Apartament {

private: char* proprietar;
		 float costIntretinere;
		 int nrPers;
public:
	Apartament() {
		this->proprietar = NULL;
		this->costIntretinere = 0;
		this->nrPers = 0;
	}

	Apartament(char* proprietar, float costIntretinere, int nrPers) {
		if (proprietar != NULL) {
			this->proprietar = new char[strlen(proprietar) + 1];
			strcpy(this->proprietar, proprietar);
		}
		else this->proprietar = NULL;
		this->costIntretinere = costIntretinere;
		this->nrPers = nrPers;
	}

	~Apartament() {
		if (this->proprietar != NULL)
			delete[] this->proprietar;
	}

	Apartament(const Apartament& ap) {
		if (ap.proprietar != NULL) {
			this->proprietar = new char[strlen(ap.proprietar) + 1];
			strcpy(this->proprietar, ap.proprietar);
}
		else this->proprietar = NULL;
		this->costIntretinere = ap.costIntretinere;
		this->nrPers = ap.nrPers;
	}

	Apartament& operator=(const Apartament& ap)
	{
		if (this->proprietar != NULL)
			delete[] this->proprietar;
		if (ap.proprietar != NULL) {
			this->proprietar = new char[strlen(ap.proprietar) + 1];
			strcpy(this->proprietar, ap.proprietar);
		}
		else this->proprietar = NULL;
		this->costIntretinere = ap.costIntretinere;
		this->nrPers = ap.nrPers;
	}

	friend ostream& operator<<(ostream& out, const Apartament& ap);

	//constr fara parametru;
	//constr cu toti parametrii
	//const de copiere;
	//op egal
	//supraincarcare operator pt afisare la consola(<<)
	//destructor


	bool operator<(Apartament at) {
		if (this->costIntretinere < at.costIntretinere)
			return true;
		else return false;
	}
};

ostream& operator<<(ostream& out, const Apartament& ap) {
	if (ap.proprietar != NULL)
		out << ap.proprietar;
	out << ap.nrPers;
	out << ap.costIntretinere;
	return out;
}

void main() {
	Apartament a1("Ion", 200, 5);
	Apartament a2("Popescu", 500, 4);
	Apartament a3("Vasile", 300, 5);
	Apartament a4("Corina", 400, 5);
	list<Apartament> Ap;
	Ap.push_back(a1);
	Ap.push_back(a2);
	Ap.push_back(a3);
	Ap.push_back(a4);

	list<Apartament>::iterator it2;
	for (it2 = Ap.begin(); it2 != Ap.end(); it2++)
		cout << *it2 << " ";

	Ap.sort();
	cout << "\n\nAfisare lista sortata";
	for (it2 = Ap.begin(); it2 != Ap.end(); it2++)
	cout << *it2 << " ";

	////utilizare vector din STL ce stocheaza elemente int
	//vector<int> v; //vector ce stocheaza elem de tip int
	//v.push_back(10); //vectorul contine val 10
	//v.push_back(20);
	//v.push_back(15);
	//
	//cout << "Afisare elemente vector\n";
	////parcurgere vector
	//for (int i = 0; i < v.size(); i++)
	//	cout << v[i] << " ";

	////parcurgere si afisare vector folosind iteratori
	//vector<int>::iterator it; //iterator ce parcurge un vector ce stocheaza elem de tip int
	//for (it = v.begin(); it != v.end(); it++)
	//	cout << *it << " ";

	////utilizare list
	//list<int>listaInt;
	//listaInt.push_back(10);
	//listaInt.push_front(20);
	//listaInt.push_back(5); 
	////afisare: 20, 10, 5;

	//cout << "\n\nAfisare lista int-uri\n";
	//list<int>::iterator itList;
	//for (itList = listaInt.begin(); itList != listaInt.end(); itList++)
	//	cout << *itList << " ";

	//listaInt.sort(); //sorteaza implicit folosind operatorul < =>sortare crescatoare;
	//cout << "\n\nAfisare lista sortata";
	//for (itList = listaInt.begin(); itList != listaInt.end(); itList++)
	//	cout << *itList << " ";

	//listaInt.reverse(); //inversare elemente lista

	////lista de apartamente;

	//list<Apartament>listaAp;
	////de incarcat 4 apartamente in listaAp(push_back)
	////de afisat lista de Ap(for);
	////de sortat lista de Ap
	////de afisare dupa sortare(sortarea se face dupa cost intretinere

}